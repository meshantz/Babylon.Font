import*as t from"@assemblyscript/loader";class e{wasm;constructor(t){this.wasm=t}static async Build(s){s??=new URL("optimized.wasm",import.meta.url).toString();const a=await t.instantiate(fetch(s),{});return new e(a)}encode(t){const e=new DataView(this.wasm.exports.memory.buffer);let s=0,a=0,o=0;for(const r of t){let t=r.type.codePointAt(0);switch(e.setUint8(s,t),s++,r.type){case"M":case"L":e.setFloat64(s,r.x,!0),s+=8,e.setFloat64(s,r.y,!0),s+=8,a=r.x,o=r.y;break;case"Q":e.setFloat64(s,a,!0),s+=8,e.setFloat64(s,o,!0),s+=8,e.setFloat64(s,r.x1,!0),s+=8,e.setFloat64(s,r.y1,!0),s+=8,e.setFloat64(s,r.x,!0),s+=8,e.setFloat64(s,r.y,!0),s+=8,a=r.x,o=r.y;break;case"C":e.setFloat64(s,a,!0),s+=8,e.setFloat64(s,o,!0),s+=8,e.setFloat64(s,r.x1,!0),s+=8,e.setFloat64(s,r.y1,!0),s+=8,e.setFloat64(s,r.x2,!0),s+=8,e.setFloat64(s,r.y2,!0),s+=8,e.setFloat64(s,r.x,!0),s+=8,e.setFloat64(s,r.y,!0),s+=8,a=r.x,o=r.y}}return s}compile(t,e,s,a){const o=this.bytesRequired(t),r=this.wasm.exports.MEMORY_BASE.value;if(o>r)return console.warn(`wasm out of mem: ${o} > ${r}`),null;const n=this.encode(t);s=Math.max(0,Math.min(255,Math.round(s))),a=Math.abs(a);const i=this.wasm.exports.compile(n,e,s,a),c=new Float64Array(this.wasm.exports.memory.buffer),l=this.wasm.exports.__getUint32Array(i),h=[];for(let t=0;t<l.length;t++){const e={fill:[],holes:[]};if(0===l[t])break;const s=this.wasm.exports.__getUint32Array(l[t]);for(const t of s){if(0===t)break;const s=this.wasm.exports.__getUint32Array(t);let a;0===e.fill.length?a=e.fill:e.holes.push(a=[]);for(const t of s){if(0===t)break;a.push([c[t>>>3],c[1+(t>>>3)]])}}h.push(e)}return h}bytesRequired(t){let e=0;for(const s of t)switch(s.type){case"M":case"L":e+=17;break;case"Q":e+=49;break;case"C":e+=65;break;case"Z":e+=1}return e}}class s{font;name;size;constructor(t,e,s){this.font=t,this.name=e,this.size=s}get ascender(){return this.font.raw.ascender/this.font.raw.unitsPerEm*this.size}get descender(){return this.font.raw.descender/this.font.raw.unitsPerEm*this.size}get advanceWidth(){return this.font.raw.getAdvanceWidth(this.name,this.size)}}class a{raw;compiler;constructor(t,e){this.raw=t,this.compiler=e}static async Install(t,e,s){const o=await s.load(t);return new a(o,e)}measure(t,e){return new s(this,t,e)}static Compile(t,e,s,a,o){const r=t.raw.getPath(e,0,0,s).commands,n=t.raw.outlinesFormat;return t.compiler.compile(r,n,a,o*s)}}class o{babylon;earcut;constructor(t,e){this.babylon=t,this.earcut=e}createFromShapes(t,e,s){const a=[],o=t=>new this.babylon.Vector3(t[0],0,-t[1]);for(const{fill:r,holes:n}of t){const t=this.babylon.MeshBuilder.CreatePolygon("",{...e,shape:r.map(o),holes:n.map((t=>t.map(o)))},s,this.earcut);a.push(t)}return a.length>0?this.babylon.Mesh.MergeMeshes(a,!0,!0):null}create({font:t,text:e,size:s=100,ppc:o=2,eps:r=.001,...n},i){const c=a.Compile(t,e,s,o,r);if(null!==c)return this.createFromShapes(c,n,i)}}export{e as Compiler,a as Font,o as TextMeshBuilder};
